name: Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      build:
        description: 'Which modules to build (auto/api/web/both)'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - api
          - web
          - both

jobs:
  init:
    runs-on: ubuntu-latest
    outputs:
      api_changes: ${{ steps.decide.outputs.api }}
      web_changes: ${{ steps.decide.outputs.web }}
      trace_tag: ${{ steps.trace.outputs.trace_tag }}

    steps:
      - uses: actions/checkout@v3

      - name: Determine trace tag
        id: trace
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          branch="${{ github.ref_name }}"
          echo "Current branch: $branch"
          
          cat << 'EOF'
          â„¹ï¸ Pipeline rules for dispatch:
            1) Main branch.
            2) Branch starting with hotfix.
            3) Branch connected to an open PR.
          
          EOF

          if [[ "$branch" == "main" ]]; then
            shortsha=$(git rev-parse --short=6 HEAD)
            echo "trace_tag=$shortsha" >> $GITHUB_OUTPUT
            echo "âœ… Run from main allowed. Trace tag (commit): $shortsha"
          elif [[ "$branch" =~ ^hotfix([/-].*|$) ]]; then
            shortsha=$(git rev-parse --short=6 HEAD)
            tag="hotfix-${shortsha}"
            echo "trace_tag=$tag" >> $GITHUB_OUTPUT
            echo "âœ… Run from hotfix branch allowed. Trace tag (hotfix-commit): $tag"
          else
            pr=$(gh pr list --head "$branch" --state open --json number --jq '.[0].number' || true)
            if [[ -n "$pr" ]]; then
              echo "trace_tag=pr-$pr" >> $GITHUB_OUTPUT
              echo "âœ… Run from branch with PR allowed. Trace tag (PR number): pr-$pr"
            else
              echo "ðŸš« Dispatch did not match rules."
              exit 1
            fi
          fi


      - name: Detect module file changes
        id: changes
        uses: dorny/paths-filter@v2
        with:
          filters: |
            api:
              - 'api/**'
            web:
              - 'web/**'

      - name: Decide final build flags (respect manual input)
        id: decide
        shell: bash
        run: |
          api="${{ steps.changes.outputs.api }}"
          web="${{ steps.changes.outputs.web }}"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            case "${{ github.event.inputs.build }}" in
              api)  api=true;  web=false ;;
              web)  api=false; web=true  ;;
              both) api=true;  web=true  ;;
              *)    : ;; # auto -> keep paths-filter values
            esac
          fi

          echo "api=$api" >> "$GITHUB_OUTPUT"
          echo "web=$web" >> "$GITHUB_OUTPUT"

  api-test:
    runs-on: ubuntu-latest
    needs: init
    if: needs.init.outputs.api_changes == 'true'
    services:
      postgres:
        image: postgres:15-alpine
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd="pg_isready -U testuser -d testdb"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20
    steps:
      - uses: actions/checkout@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'maven'

      - name: Wait for Postgres
        run: |
          for i in {1..30}; do
            if pg_isready -h 127.0.0.1 -p 5432 -U testuser >/dev/null 2>&1; then
              echo "âœ… Postgres is ready"
              exit 0
            fi
            echo "â³ Waiting for Postgres... ($i/30)"
            sleep 2
          done
          echo "âš ï¸ Postgres not reachable, continuing anyway (tests may not need DB)."

      - name: Run unit tests
        working-directory: api
        env:
          API_DB_HOST: 127.0.0.1
          API_DB_PORT: 5432
          API_DB_DATABASE: testdb
          API_DB_USER: testuser
          API_DB_PASSWORD: testpass
          API_AWS_ACCESS_KEY: ${{ secrets.API_AWS_ACCESS_KEY }}
          API_AWS_SECRET_KEY: ${{ secrets.API_AWS_SECRET_KEY }}
          API_AWS_REGION: ${{ vars.API_AWS_REGION }}
          API_AWS_S3_BUCKET_NAME: ${{ vars.API_AWS_S3_BUCKET_NAME }}
          API_ALLOWED_ORIGINS: ${{ vars.API_ALLOWED_ORIGINS }}
        run: |
          mvn -B -U test \
             -DtrimStackTrace=false \
             -Dsurefire.printSummary=true \
             -Dsurefire.useFile=false \
             -DforkCount=0

  api-build:
    runs-on: ubuntu-latest
    needs: [init, api-test]
    if: needs.init.outputs.api_changes == 'true' && needs.api-test.result == 'success'
    steps:
      - uses: actions/checkout@v3

      - uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - uses: docker/setup-buildx-action@v3

      - name: Build and push (with cache)
        uses: docker/build-push-action@v5
        with:
          context: ./api
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ vars.DOCKER_REPO }}:${{ vars.DOCKER_API_IMAGE_TAG }}
            ${{ vars.DOCKER_REPO }}:${{ needs.init.outputs.trace_tag }}
          cache-from: |
            type=gha,scope=api
            type=registry,ref=${{ vars.DOCKER_REPO }}:buildcache
          cache-to: |
            type=gha,scope=api,mode=max
            type=registry,ref=${{ vars.DOCKER_REPO }}:buildcache,mode=max,compression=zstd

  api-deploy:
    runs-on: ubuntu-latest
    needs: api-build
    if: needs.init.outputs.api_changes == 'true'
    steps:
      - name: Set up SSH key
        run: |
          echo "${{ secrets.DEPLOY_API_SSH_KEY }}" > key.pem
          chmod 600 key.pem

      - name: Add EC2 to known_hosts
        run: |
          mkdir -p ~/.ssh 
          ssh-keyscan -H ${{ secrets.DEPLOY_API_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Generate .env file
        run: |
          {
            echo "API_DB_HOST=${{ vars.API_DB_HOST }}"
            echo "API_DB_PORT=${{ vars.API_DB_PORT }}"
            echo "API_DB_DATABASE=${{ vars.API_DB_DATABASE }}"
            echo "API_DB_USER=${{ secrets.API_DB_USER }}"
            echo "API_DB_PASSWORD=${{ secrets.API_DB_PASSWORD }}"
            echo "API_AWS_ACCESS_KEY=${{ secrets.API_AWS_ACCESS_KEY }}"
            echo "API_AWS_SECRET_KEY=${{ secrets.API_AWS_SECRET_KEY }}"
            echo "API_AWS_REGION=${{ vars.API_AWS_REGION }}"
            echo "API_AWS_S3_BUCKET_NAME=${{ vars.API_AWS_S3_BUCKET_NAME }}"
            echo "API_ALLOWED_ORIGINS=${{ vars.API_ALLOWED_ORIGINS }}"
            echo "DOCKER_API_IMAGE_TAG=${{ vars.DOCKER_API_IMAGE_TAG }}"
            echo "DOCKER_REPO=${{ vars.DOCKER_REPO }}"
          } > .env

      - name: Upload .env to EC2 home directory
        run: |
          scp -i key.pem .env ${{ secrets.DEPLOY_API_SSH_USER }}@${{ secrets.DEPLOY_API_SSH_HOST }}:~/

      - name: Move .env into /opt/docker
        run: |
          ssh -i key.pem ${{ secrets.DEPLOY_API_SSH_USER }}@${{ secrets.DEPLOY_API_SSH_HOST }} '
          sudo mv -f ~/\.env /opt/docker/.env
          '

      - name: Update docker compose with health check
        run: |
          ssh -i key.pem ${{ secrets.DEPLOY_API_SSH_USER }}@${{ secrets.DEPLOY_API_SSH_HOST }} <<'EOF'
            set -e
            cd /opt/docker

            docker compose down
            docker compose pull

            set +e
            docker compose up -d --wait --wait-timeout 120
            rc=$?
            set -e

            if [ $rc -ne 0 ]; then
              echo "âŒ Some services failed or became unhealthy:"
              docker compose ps
              echo "â€” recent logs from all services â€”"
              docker compose logs --tail=200
              exit $rc
            fi

            echo "âœ… All services are healthy:"
            docker compose ps
          EOF


  web-build:
    runs-on: ubuntu-latest
    needs: [init, api-deploy]
    if: |
      needs.init.outputs.web_changes == 'true' &&
      (needs.api-deploy.result == 'success' || needs.api-deploy.result == 'skipped') && always()
    steps:
      - uses: actions/checkout@v3

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: web/package-lock.json

      - name: Install dependencies
        run: cd web && npm ci

      - name: Build frontend
        env:
          VITE_ENV: ${{ vars.VITE_ENV }}
          VITE_APP_VERSION: ${{ needs.init.outputs.trace_tag }}
          VITE_BUILD_USERNAME: ${{ secrets.VITE_BUILD_USERNAME }}
          VITE_BUILD_PASSWORD: ${{ secrets.VITE_BUILD_PASSWORD }}
          VITE_FRONTEND_URL: ${{ vars.VITE_FRONTEND_URL }}
          VITE_BACKEND_URL: ${{ vars.VITE_BACKEND_URL }}
          VITE_BACKEND_PROXY_SLUG: ${{ vars.VITE_BACKEND_PROXY_SLUG }}
        run: cd web && npm run build

      - name: Upload frontend artifact
        uses: actions/upload-artifact@v4
        with:
          name: web-dist
          path: web/dist/static

  web-deploy:
    runs-on: ubuntu-latest
    needs: web-build
    if: needs.init.outputs.web_changes == 'true' && always()
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.DEPLOY_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.DEPLOY_SECRET_KEY }}
          aws-region: us-east-1

      - name: Download frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: web-dist
          path: ./dist/static

      - name: Sync to S3
        run: aws s3 sync ./dist/static s3://${{ vars.DEPLOY_WEB_BUCKET_NAME }} --delete

      - name: Invalidate CloudFront cache
        if: vars.DEPLOY_WEB_CLOUDFRONT_DISTRIBUTION_ID != ''
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ vars.DEPLOY_WEB_CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*"